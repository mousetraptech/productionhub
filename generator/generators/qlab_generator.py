"""
QLab OSC Cue Builder Generator
===============================
Generates a Python script that uses python-osc to programmatically
build a QLab workspace from an event definition.

The generated script:
  - Connects to QLab via OSC on port 53000
  - Creates cue groups for each show phase
  - Creates individual cues with proper types, names, and properties
  - Sets pre/post waits, fade durations, and follow cues
  - Includes timing delays between commands to let QLab process
"""

from typing import Any


class QLabGenerator:
    """Generates a QLab OSC cue-building Python script from an event definition."""

    def __init__(self, event_data: dict):
        self.event = event_data

    def generate(self) -> str:
        """Generate the complete Python script as a string."""
        lines = []
        lines.append(self._header())
        lines.append(self._imports())
        lines.append(self._config())
        lines.append(self._helper_functions())
        lines.append(self._build_function())
        lines.append(self._main_block())
        return "\n".join(lines)

    def _header(self) -> str:
        event_name = self.event.get("event_name", "Untitled")
        event_type = self.event.get("event_type", "unknown")
        return f'''#!/usr/bin/env python3
"""
QLab Cue Builder: {event_name}
{'=' * (20 + len(event_name))}
Auto-generated by the Production Event Template System.

This script connects to QLab via OSC and programmatically creates
all cues defined in the "{event_type}" event template.

Requirements:
    pip install python-osc

Usage:
    python {event_type}_qlab_cues.py [--host HOST] [--port PORT] [--passcode CODE]

IMPORTANT: Run this with QLab open and a workspace active.
The script will CREATE cues in the frontmost workspace.
"""
'''

    def _imports(self) -> str:
        return '''import argparse
import sys
import time

from pythonosc.udp_client import SimpleUDPClient

'''

    def _config(self) -> str:
        network = self.event.get("network", {})
        qlab = network.get("qlab", {})
        host = qlab.get("host", "127.0.0.1")
        port = qlab.get("port", 53000)
        passcode = qlab.get("passcode", "1234")

        hub = network.get("hub", {})
        hub_host = hub.get("host", "127.0.0.1")
        hub_port = hub.get("port", 9000)

        return f'''# --- Configuration ---
DEFAULT_HOST = "{host}"
DEFAULT_PORT = {port}
DEFAULT_PASSCODE = "{passcode}"

# Production Hub OSC target (where network cues send their messages)
HUB_HOST = "{hub_host}"
HUB_PORT = {hub_port}

# Delay between OSC commands (seconds) to let QLab process each one
CMD_DELAY = 0.1

'''

    def _helper_functions(self) -> str:
        return '''# --- Helper Functions ---

def send(client: SimpleUDPClient, address: str, *args) -> None:
    """Send an OSC message and wait for QLab to process it."""
    if args and args[0] is not None:
        client.send_message(address, list(args))
    else:
        client.send_message(address, [])
    time.sleep(CMD_DELAY)


def connect_workspace(client: SimpleUDPClient, passcode: str) -> None:
    """Connect to the frontmost QLab workspace."""
    print(f"  Connecting to QLab workspace (passcode: {passcode})...")
    send(client, "/connect", passcode)
    time.sleep(0.5)


def new_cue(client: SimpleUDPClient, cue_type: str) -> None:
    """Create a new cue of the specified type. The new cue becomes selected."""
    send(client, "/new", cue_type)


def set_cue_property(client: SimpleUDPClient, prop: str, value) -> None:
    """Set a property on the currently selected cue."""
    send(client, f"/cue/selected/{prop}", value)


def move_cue_into_group(client: SimpleUDPClient, cue_number: str, group_number: str) -> None:
    """Move a cue into a group cue by number.

    Uses /move/{cue_id} with the group's cue_id as the target.
    QLab moves the cue to the END of the target group's children.
    The index argument 0 means "last position in group".
    """
    # /cue/{cue}/moveAfter/{target} — but the simplest reliable approach
    # is: select the cue, then use /move/selected to the group.
    # However, QLab's best-documented approach for OSC is:
    #   /move/{cue_number} {row_index}
    # where the cue is placed at row_index in the cue list, and if the
    # target row is inside a group, it goes into that group.
    #
    # The most reliable method: use /cue/{number}/parent to reparent directly.
    # This is a QLab 5 property: setting it to a group's cue_id moves the cue.
    send(client, f"/cue/{cue_number}/parent", group_number)


def create_group(client: SimpleUDPClient, name: str, number: str = "") -> None:
    """Create a group cue container."""
    new_cue(client, "group")
    set_cue_property(client, "name", name)
    if number:
        set_cue_property(client, "number", number)
    # Set group mode to "cue list" so it acts as a container
    set_cue_property(client, "mode", 0)
    print(f"  Created group: {name}")


def create_memo(client: SimpleUDPClient, name: str, notes: str = "") -> None:
    """Create a memo/placeholder cue."""
    new_cue(client, "memo")
    set_cue_property(client, "name", name)
    if notes:
        set_cue_property(client, "notes", notes)


def create_network_cue(
    client: SimpleUDPClient,
    name: str,
    number: str,
    osc_path: str,
    osc_args: list | None = None,
    dest_host: str = "",
    dest_port: int = 0,
    pre_wait: float = 0,
    post_wait: float = 0,
    color: str = "",
    notes: str = "",
) -> None:
    """Create a network cue that sends an OSC command to a target host."""
    new_cue(client, "network")
    set_cue_property(client, "name", name)
    set_cue_property(client, "number", number)
    # Configure as OSC message type
    set_cue_property(client, "messageType", 1)
    # Build the raw OSC string: address followed by args
    if osc_args:
        raw = osc_path + " " + " ".join(str(a) for a in osc_args)
    else:
        raw = osc_path
    set_cue_property(client, "rawString", raw)
    # Set destination host and port
    if dest_host:
        set_cue_property(client, "udpIP", dest_host)
    if dest_port:
        set_cue_property(client, "udpPort", dest_port)
    if pre_wait > 0:
        set_cue_property(client, "preWait", pre_wait)
    if post_wait > 0:
        set_cue_property(client, "postWait", post_wait)
    if color:
        set_cue_property(client, "colorName", color)
    if notes:
        set_cue_property(client, "notes", notes)
    print(f"  Created cue Q{number}: {name} -> {raw}")


def create_light_cue(
    client: SimpleUDPClient,
    name: str,
    number: str,
    fade_duration: float = 0,
    pre_wait: float = 0,
    color: str = "yellow",
    notes: str = "",
) -> None:
    """Create a lighting cue."""
    new_cue(client, "light")
    set_cue_property(client, "name", name)
    set_cue_property(client, "number", number)
    if fade_duration > 0:
        set_cue_property(client, "duration", fade_duration)
    if pre_wait > 0:
        set_cue_property(client, "preWait", pre_wait)
    set_cue_property(client, "colorName", color)
    if notes:
        set_cue_property(client, "notes", notes)
    print(f"  Created light cue Q{number}: {name}")

'''

    def _build_function(self) -> str:
        """Generate the main build_show() function with all cues.

        Uses a two-pass approach:
          Pass 1: Create all groups and cues (they land flat at the root level)
          Pass 2: Move each cue into its parent group using /cue/{num}/parent
        This is necessary because QLab's /new always appends to the root of the
        cue list — there's no way to create a cue directly inside a group via OSC.
        """
        lines = []
        lines.append("def build_show(client: SimpleUDPClient) -> None:")
        event_name = self.event.get("event_name", "Untitled")
        lines.append(f'    """Build the complete cue list for: {event_name}')
        lines.append("")
        lines.append("    Two-pass build:")
        lines.append("      Pass 1 - Create all groups and cues (flat, at root level)")
        lines.append("      Pass 2 - Move cues into their parent groups")
        lines.append('    """')
        lines.append(f'    print("\\nBuilding show: {event_name}")')
        lines.append(f'    print("{"=" * 50}")')
        lines.append("")

        cues = self.event.get("cues", [])
        pre_show = [c for c in cues if c.get("timing") == "pre-show"]
        show_cues = [c for c in cues if c.get("timing") not in ("pre-show", "post-show")]
        post_show = [c for c in cues if c.get("timing") == "post-show"]

        # ── Pass 1: Create everything flat ──
        lines.append('    # ══════════════════════════════════════════════════')
        lines.append('    # PASS 1: Create all groups and cues')
        lines.append('    # (everything lands at the root level of the cue list)')
        lines.append('    # ══════════════════════════════════════════════════')
        lines.append('    print("\\nPass 1: Creating cues...")')
        lines.append("")

        # Create the three group cues first
        lines.append('    # --- Group containers ---')
        lines.append('    create_group(client, "PRE-SHOW", "G_PRE")')
        lines.append('    create_group(client, "SHOW", "G_SHOW")')
        lines.append('    create_group(client, "POST-SHOW", "G_POST")')
        lines.append("")

        # Create all cues
        lines.append('    # --- Pre-Show Cues ---')
        lines.append('    print("\\n  Pre-Show cues:")')
        for cue in pre_show:
            lines.append(self._cue_creation_code(cue))

        lines.append('    # --- Show Cues ---')
        lines.append('    print("\\n  Show cues:")')
        for cue in show_cues:
            lines.append(self._cue_creation_code(cue))

        lines.append('    # --- Post-Show Cues ---')
        lines.append('    print("\\n  Post-Show cues:")')
        for cue in post_show:
            lines.append(self._cue_creation_code(cue))

        # ── Pass 2: Move cues into groups ──
        lines.append('    # ══════════════════════════════════════════════════')
        lines.append('    # PASS 2: Move cues into their parent groups')
        lines.append('    # Uses /cue/{number}/parent to reparent each cue')
        lines.append('    # ══════════════════════════════════════════════════')
        lines.append('    print("\\nPass 2: Organizing cues into groups...")')
        lines.append('    time.sleep(0.5)  # Let QLab finish processing all creates')
        lines.append("")

        # First, move sub-cues into their multi-action group cues
        multi_action_cues = [c for c in cues if len(c.get("hub_actions", [])) > 1]
        if multi_action_cues:
            lines.append('    # Move sub-cues into their multi-action group cues')
            for cue in multi_action_cues:
                num = cue.get("number", "000")
                name = cue.get("name", "?")
                count = len(cue["hub_actions"])
                for i in range(1, count + 1):
                    lines.append(f'    move_cue_into_group(client, "{num}.{i}", "{num}")  # {name} [{i}/{count}]')
            lines.append("")

        # Move pre-show cues into G_PRE
        if pre_show:
            lines.append('    # Move pre-show cues into PRE-SHOW group')
            for cue in pre_show:
                num = cue.get("number", "000")
                name = cue.get("name", "?")
                lines.append(f'    move_cue_into_group(client, "{num}", "G_PRE")  # {name}')
            lines.append(f'    print("  Moved {len(pre_show)} cues into PRE-SHOW")')
            lines.append("")

        # Move show cues into G_SHOW
        if show_cues:
            lines.append('    # Move show cues into SHOW group')
            for cue in show_cues:
                num = cue.get("number", "000")
                name = cue.get("name", "?")
                lines.append(f'    move_cue_into_group(client, "{num}", "G_SHOW")  # {name}')
            lines.append(f'    print("  Moved {len(show_cues)} cues into SHOW")')
            lines.append("")

        # Move post-show cues into G_POST
        if post_show:
            lines.append('    # Move post-show cues into POST-SHOW group')
            for cue in post_show:
                num = cue.get("number", "000")
                name = cue.get("name", "?")
                lines.append(f'    move_cue_into_group(client, "{num}", "G_POST")  # {name}')
            lines.append(f'    print("  Moved {len(post_show)} cues into POST-SHOW")')
            lines.append("")

        lines.append(f'    print("\\n{"=" * 50}")')
        lines.append(f'    print("Show build complete! {len(cues)} cues organized into 3 groups.")')
        lines.append(f'    print("  PRE-SHOW:  {len(pre_show)} cues")')
        lines.append(f'    print("  SHOW:      {len(show_cues)} cues")')
        lines.append(f'    print("  POST-SHOW: {len(post_show)} cues")')
        lines.append("")

        return "\n".join(lines)

    def _cue_creation_code(self, cue: dict) -> str:
        """Generate Python code to create a single cue."""
        cue_type = cue.get("type", "system")
        number = cue.get("number", "000")
        name = cue.get("name", "Untitled")
        description = cue.get("description", "")
        fade = cue.get("fade_duration", 0)
        follow = cue.get("follow", 0)
        hub_actions = cue.get("hub_actions", [])

        # Map cue types to colors
        color_map = {
            "lighting": "yellow",
            "audio": "green",
            "video": "blue",
            "system": "purple",
        }
        color = color_map.get(cue_type, "none")

        # If hub_actions are defined, generate network cues targeting the hub
        if hub_actions:
            return self._hub_action_code(cue, hub_actions, color)

        # Fallback: no hub_actions (backward compat)
        if cue_type == "lighting":
            return f'''    create_light_cue(
        client,
        name="{name}",
        number="{number}",
        fade_duration={fade},
        color="{color}",
        notes="{description}",
    )
'''
        else:
            return f'''    create_network_cue(
        client,
        name="{name}",
        number="{number}",
        osc_path="/cue/{number}/fire",
        post_wait={follow},
        color="{color}",
        notes="{description}",
    )
'''

    def _hub_action_code(self, cue: dict, hub_actions: list, color: str) -> str:
        """Generate code for a cue with hub_actions."""
        number = cue.get("number", "000")
        name = cue.get("name", "Untitled")
        description = cue.get("description", "")
        follow = cue.get("follow", 0)

        if len(hub_actions) == 1:
            # Single action: one network cue
            action = hub_actions[0]
            address = action.get("address", "")
            args = action.get("args")
            args_str = repr(args) if args else "None"
            return f'''    create_network_cue(
        client,
        name="{name}",
        number="{number}",
        osc_path="{address}",
        osc_args={args_str},
        dest_host=HUB_HOST,
        dest_port=HUB_PORT,
        post_wait={follow},
        color="{color}",
        notes="{description}",
    )
'''
        else:
            # Multiple actions: group cue with sub-cues
            lines = []
            lines.append(f'    # Q{number}: {name} ({len(hub_actions)} hub actions)')
            lines.append(f'    create_group(client, "{name}", "{number}")')
            lines.append(f'    set_cue_property(client, "mode", 4)  # fire all children')
            if follow:
                lines.append(f'    set_cue_property(client, "postWait", {follow})')
            lines.append(f'    set_cue_property(client, "colorName", "{color}")')
            if description:
                lines.append(f'    set_cue_property(client, "notes", "{description}")')
            lines.append("")
            for i, action in enumerate(hub_actions, 1):
                address = action.get("address", "")
                args = action.get("args")
                args_str = repr(args) if args else "None"
                lines.append(f'    create_network_cue(')
                lines.append(f'        client,')
                lines.append(f'        name="{name} [{i}/{len(hub_actions)}]",')
                lines.append(f'        number="{number}.{i}",')
                lines.append(f'        osc_path="{address}",')
                lines.append(f'        osc_args={args_str},')
                lines.append(f'        dest_host=HUB_HOST,')
                lines.append(f'        dest_port=HUB_PORT,')
                lines.append(f'    )')
            lines.append("")
            return "\n".join(lines) + "\n"

    def _main_block(self) -> str:
        return '''
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Build QLab cues from event template"
    )
    parser.add_argument("--host", default=DEFAULT_HOST, help="QLab host IP")
    parser.add_argument("--port", type=int, default=DEFAULT_PORT, help="QLab OSC port")
    parser.add_argument("--passcode", default=DEFAULT_PASSCODE, help="Workspace passcode")
    parser.add_argument(
        "--dry-run", action="store_true",
        help="Print what would be created without connecting to QLab"
    )
    args = parser.parse_args()

    if args.dry_run:
        print("DRY RUN - no OSC commands will be sent")
        print("(Use without --dry-run to build cues in QLab)")
        sys.exit(0)

    print(f"Connecting to QLab at {args.host}:{args.port}")
    client = SimpleUDPClient(args.host, args.port)
    connect_workspace(client, args.passcode)
    build_show(client)
    print("\\nDone. Check QLab to verify cues were created correctly.")
'''

    def write(self, output_path: str) -> str:
        """Generate and write the QLab script to a file."""
        script = self.generate()
        with open(output_path, "w") as f:
            f.write(script)
        return output_path
