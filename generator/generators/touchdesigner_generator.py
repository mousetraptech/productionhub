"""
TouchDesigner Setup Script Generator
=====================================
Generates a Python script that runs INSIDE TouchDesigner to set up
the video switching and OSC control network from an event definition.

The generated script:
  - Creates Video Device In TOPs for each camera
  - Creates a Switch TOP for camera switching
  - Sets up an OSC In DAT for receiving cue triggers
  - Creates an Execute DAT with the cue handler logic
  - Configures output resolution and format
"""

from typing import Any


class TouchDesignerGenerator:
    """Generates a TouchDesigner Python setup script from an event definition."""

    def __init__(self, event_data: dict):
        self.event = event_data

    def generate(self) -> str:
        """Generate the complete TouchDesigner setup script."""
        lines = []
        lines.append(self._header())
        lines.append(self._camera_setup())
        lines.append(self._switch_setup())
        lines.append(self._osc_setup())
        lines.append(self._cue_handler())
        lines.append(self._output_setup())
        lines.append(self._main_block())
        return "\n".join(lines)

    def _header(self) -> str:
        event_name = self.event.get("event_name", "Untitled")
        event_type = self.event.get("event_type", "unknown")
        return f'''"""
TouchDesigner Setup Script: {event_name}
{'=' * (30 + len(event_name))}
Auto-generated by the Production Event Template System.

HOW TO USE:
  1. Open TouchDesigner
  2. Create a new Text DAT (right-click > DAT > Text)
  3. Paste this entire script into the Text DAT
  4. Right-click the Text DAT > Run Script
  5. The script will create all operators in the /project1 container

The script builds:
  - Video Device In TOPs for each camera input
  - A Switch TOP for live camera switching
  - OSC In DAT for receiving messages from the Production Hub
  - Cue handler logic for automated switching
  - Render output pipeline

Event type: {event_type}
"""

'''

    def _camera_setup(self) -> str:
        cameras = self.event.get("video", {}).get("cameras", [])
        lines = []
        lines.append("# " + "=" * 60)
        lines.append("# CAMERA INPUT SETUP")
        lines.append("# " + "=" * 60)
        lines.append("")
        lines.append("def setup_cameras():")
        lines.append('    """Create Video Device In TOPs for each camera."""')
        lines.append("    project = op('/project1')")
        lines.append("")

        for i, cam in enumerate(cameras):
            cam_id = cam.get("id", f"cam{i+1}")
            resolution = cam.get("resolution", "1920x1080")
            fps = cam.get("fps", 30)
            shot = cam.get("shot", "wide")
            position = cam.get("position", "unknown")
            w, h = resolution.split("x")

            lines.append(f'    # {cam_id}: {shot} shot from {position}')
            lines.append(f'    {cam_id} = project.create(videodeviceinTOP, "{cam_id}")')
            lines.append(f'    {cam_id}.par.device = {i}')
            lines.append(f'    {cam_id}.par.resolutionw = {w}')
            lines.append(f'    {cam_id}.par.resolutionh = {h}')
            lines.append(f'    {cam_id}.par.rate = {fps}')
            lines.append(f'    {cam_id}.nodeX = {i * 250}')
            lines.append(f'    {cam_id}.nodeY = 0')
            lines.append(f'    {cam_id}.comment = "{shot} shot - {position}"')
            lines.append("")

        lines.append(f'    print("Created {len(cameras)} camera inputs")')
        lines.append(f'    return [{", ".join(c.get("id", f"cam{i+1}") for i, c in enumerate(cameras))}]')
        lines.append("")
        return "\n".join(lines)

    def _switch_setup(self) -> str:
        cameras = self.event.get("video", {}).get("cameras", [])
        default_cam = self.event.get("video", {}).get("switching", {}).get("default_camera", "cam1")
        default_idx = 0
        for i, cam in enumerate(cameras):
            if cam.get("id") == default_cam:
                default_idx = i
                break

        return f'''
# {"=" * 60}
# VIDEO SWITCH SETUP
# {"=" * 60}

def setup_switch(cameras):
    """Create a Switch TOP to cut between camera inputs."""
    project = op('/project1')

    switch = project.create(switchTOP, "video_switch")
    switch.par.index = {default_idx}  # Default to {default_cam}
    switch.nodeX = {len(cameras) * 125}
    switch.nodeY = -200
    switch.comment = "Main video switch - controlled via OSC"

    # Connect all camera inputs to the switch
    for i, cam in enumerate(cameras):
        cam.outputConnectors[0].connect(switch)

    print(f"Video switch created with {{len(cameras)}} inputs (default: input {default_idx})")
    return switch

'''

    def _osc_setup(self) -> str:
        network = self.event.get("network", {})
        td_config = network.get("touchdesigner", {})
        osc_port = td_config.get("osc_listen_port", 7000)

        return f'''
# {"=" * 60}
# OSC INPUT SETUP
# {"=" * 60}

def setup_osc():
    """Create OSC In DAT for receiving cue triggers."""
    project = op('/project1')

    # OSC input for receiving cue commands
    osc_in = project.create(oscInDAT, "osc_input")
    osc_in.par.port = {osc_port}
    osc_in.par.active = True
    osc_in.nodeX = 500
    osc_in.nodeY = 200
    osc_in.comment = "Receives OSC from Production Hub (/td prefix stripped)"

    print(f"OSC input listening on port {osc_port}")
    return osc_in

'''

    def _cue_handler(self) -> str:
        cameras = self.event.get("video", {}).get("cameras", [])
        cues = self.event.get("cues", [])

        # Build camera switch mapping from hub_actions that target /td/...
        # The hub strips the /td prefix, so TD receives the remainder.
        handler_cases = []
        for cue in cues:
            for action in cue.get("hub_actions", []):
                address = action.get("address", "")
                if address.startswith("/td/"):
                    td_address = address[3:]  # strip /td -> /camera/switch
                    args = action.get("args", [])
                    name = cue.get("name", "")
                    handler_cases.append(
                        f"        '{td_address}': {args},  # {name}"
                    )

        cue_map_str = "\n".join(handler_cases) if handler_cases else "        # No TD cues defined in this template"

        return f'''
# {"=" * 60}
# CUE HANDLER
# {"=" * 60}

def setup_cue_handler(osc_in):
    """Create an Execute DAT that handles incoming OSC messages from the hub."""
    project = op('/project1')

    handler = project.create(textDAT, "cue_handler")
    handler.nodeX = 500
    handler.nodeY = 0
    handler.comment = "Handles OSC messages from Production Hub"

    # The cue handler script that runs inside the Execute DAT
    handler.text = \'\'\'# Cue Handler - auto-generated by Event Template System
# Receives OSC from the Production Hub (after /td prefix is stripped).

# Static action map from hub_actions (address -> args)
ACTION_MAP = {{
{cue_map_str}
    }}

def onReceiveOSC(address, args):
    """Called when an OSC message is received from the hub."""
    # Camera switching: /camera/switch <index>
    if address == "/camera/switch":
        camera_index = int(args[0]) if args else 0
        op("video_switch").par.index = camera_index
        print(f"Camera switch -> {{camera_index}}")
        return

    # Check static action map
    if address in ACTION_MAP:
        print(f"Action: {{address}} {{ACTION_MAP[address]}}")
        return

    # Generic parameter control: /param/<name> <value>
    parts = address.strip("/").split("/")
    if len(parts) >= 2 and parts[0] == "param":
        param_name = parts[1]
        value = float(args[0]) if args else 0
        print(f"Param: {{param_name}} = {{value}}")
        return

    # Log unhandled messages
    print(f"OSC (unhandled): {{address}} {{args}}")
\'\'\'

    # Create Execute DAT to wire OSC input to handler
    exe = project.create(executeDAT, "osc_execute")
    exe.par.dat = osc_in
    exe.par.active = True
    exe.nodeX = 500
    exe.nodeY = 100
    exe.comment = "Triggers cue_handler on OSC input"

    print("Cue handler configured")
    return handler

'''

    def _output_setup(self) -> str:
        recording = self.event.get("video", {}).get("recording", {})
        rec_format = recording.get("format", "h264")
        bitrate = recording.get("bitrate", "20Mbps")

        return f'''
# {"=" * 60}
# OUTPUT PIPELINE
# {"=" * 60}

def setup_output(switch):
    """Create the output pipeline from the video switch."""
    project = op('/project1')

    # Null TOP as a clean output reference point
    output = project.create(nullTOP, "program_output")
    switch.outputConnectors[0].connect(output)
    output.nodeX = switch.nodeX + 250
    output.nodeY = switch.nodeY
    output.comment = "Program output - connect to recording or streaming"

    # Info overlay for monitoring
    info = project.create(textTOP, "output_info")
    info.par.text = "PROGRAM OUTPUT"
    info.par.fontsizex = 20
    info.nodeX = output.nodeX
    info.nodeY = output.nodeY - 150
    info.comment = "Output status overlay"

    print("Output pipeline created")
    print("  Recording format: {rec_format}")
    print("  Target bitrate: {bitrate}")
    return output

'''

    def _main_block(self) -> str:
        event_name = self.event.get("event_name", "Untitled")
        return f'''
# {"=" * 60}
# MAIN - Run this to build the entire network
# {"=" * 60}

def build_network():
    """Build the complete TouchDesigner network for this event."""
    print("")
    print("Building TouchDesigner network: {event_name}")
    print("{"=" * 55}")

    cameras = setup_cameras()
    switch = setup_switch(cameras)
    osc_in = setup_osc()
    setup_cue_handler(osc_in)
    output = setup_output(switch)

    print("")
    print("{"=" * 55}")
    print("Network build complete!")
    print("  - Camera inputs are ready (assign physical devices)")
    print("  - Video switch is set to default camera")
    print("  - OSC input is listening for cue triggers")
    print("  - Program output is available at /project1/program_output")
    print("")
    print("Next steps:")
    print("  1. Verify camera device assignments in each Video Device In")
    print("  2. Test OSC input from QLab/Companion")
    print("  3. Connect program_output to your recording/streaming pipeline")
    print("")


# Run the build
build_network()
'''

    def write(self, output_path: str) -> str:
        """Generate and write the TouchDesigner script to a file."""
        script = self.generate()
        with open(output_path, "w") as f:
            f.write(script)
        return output_path
